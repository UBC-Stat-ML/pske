#include "ProbSKE.h"

/*
 *  C code for Taylor approximation of the skeletoid
 *  DEPRECATED: this was used before we knew the high-precision implementation
 *              of skeletoid
 */

/* .Call() this from R : */
SEXP R_skeletoid_expm_Taylor(SEXP Q_, SEXP delta_, SEXP N_, SEXP n_sq_)
{
  size_t N = asInteger(N_), n_sq = asInteger(n_sq_);
  double delta = asReal(delta_), *pQ, *pU;
  int nprotect = 0;
  SEXP U, Q;
  PROTECT(U = allocMatrix(REALSXP, N, N)); nprotect++; // update mat, eventually returned as answer
  pU = REAL(U); // get pointer
  Q = PROTECT(duplicate(Q_)); nprotect++; /* need to duplicate Q_ since it is modified */
  pQ = REAL(Q); // get pointer
  skeletoid_expm_Taylor(pQ,pU,delta,N,n_sq); // squaring loop
  UNPROTECT(nprotect); /* unprotect and return */
  return(U);
}

/* actual function, carries out the work */
void skeletoid_expm_Taylor(double *Q, double *U, double delta, int N, size_t n_sq){
  size_t k, NSqr = N * N;
  double *R = (double*)malloc(sizeof(double) * NSqr); // 2nd order term in expansion
  double *tmp = (double*)malloc(sizeof(double) * NSqr); // temp storage for dgemm
  static const char *trans = "N";
  static const double one = 1.0, zero = 0.0;
  
  build_R(R,Q,N); // initialize R
    
  /* squaring loop */
  for (k = 0; k < n_sq; k++){
    get_U(Q, R, U, one, delta, N); /* computes U in place */
    F77_CALL(dgemm)(trans, trans, &N, &N, &N, &one, /* tmp <- QU */
      Q, &N, U, &N, &zero, tmp, &N FCONE FCONE);
    Memcpy(Q, tmp, NSqr); /* Q <- tmp  */
    F77_CALL(dgemm)(trans, trans, &N, &N, &N, &one, /* tmp <- RU */
      R, &N, U, &N, &zero, tmp, &N FCONE FCONE);
    Memcpy(R, tmp, NSqr); /* R <- tmp */
  }
  free(tmp);
  
  /* computes U in place */
  get_U(Q, R, U, zero, delta, N);
  free(R);
}

/* Compute U = (1+x)I + delta(Q + (0.5*delta)*R) 
 * Use x = 1.0 for updating U and x = 0.0 for answer
 */
void get_U(double *Q, double *R, double *U, double x, double delta, size_t N)
{
  size_t i,j;
  
  for (j = 0; j < N; j++){ /* loop columns first (faster) */
    for (i = 0; i < N; i++){
      U[i + j*N] = ((i == j) ? (x+1.0) : (0.0)) + delta*(Q[i + j*N] + (0.5*delta)*R[i + j*N]);
    }
  }
}

/* Compute R_ij = Ind(i==j)Qii^2 + Ind(i!=j)Qij(Qii+Qjj), exploting symmetry */
void build_R(double *R, double *Q, size_t N){
  size_t i,j;
  double dqj, *dQ = (double*)malloc(sizeof(double) * N); // diag(Q)
  double *qii_p_qjj = (double*)malloc(sizeof(double) * N * N); // qii + qjj
  
  /*  fetch diag(Q) to avoid jumping around all over Q in next loops */
  for( i=0; i<N; i++){
    dQ[i] = Q[i + N*i];
  }
  
  /* populate (strict) upper triangle of qii_p_qjj */
  for( j=0; j<N; j++){
    dqj = dQ[j]; // fetch qjj
    for( i=0; i<j; i++){
      qii_p_qjj[i + N*j] = dQ[i] + dqj;
    }
  }
  
  /* populate R */
  for( j=0; j<N; j++){
    for( i=0; i<N; i++){
      if(i==j){
        dqj = dQ[i]; // fetch qii
        R[i + N*i] = dqj*dqj;
      } else if(i<j){
        R[i + N*j] = Q[i + N*j]*qii_p_qjj[i + N*j];
      } else{
        R[i + N*j] = Q[i + N*j]*qii_p_qjj[j + N*i]; // "transpose" qii_p_qjj
      }
    }
  }
  free(dQ);
  free(qii_p_qjj);
}