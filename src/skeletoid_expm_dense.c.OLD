// UNSAFE
void skeletoid_expm_dense(double *S, double *Q, double delta, size_t n, size_t n_sq) {
  size_t i, j;
  double dqj, qii_m_qjj;
  double* dQ = (double*)malloc(sizeof(double) * n); // dQ = diag(Q)
  double* p_0 = (double*)malloc(sizeof(double) * n); // p_0 = exp(delta*diag(Q))
  double* S_sym = (double*)malloc(sizeof(double) * n * n); // symmetric part of S_delta
  
  /*  fetch diag(Q), compute diagonal of S_delta=p_0 */
  for( i=0; i<n; i++){
    dQ[i] = Q[i + n*i];
    p_0[i] = exp(delta*(dQ[i]));
  }
  
  /* populate upper triangle of S_sym */
  for( j=0; j<n; j++){
    dqj = dQ[j]; // fetch qjj
    for( i=0; i<j; i++){ // only do (strict) upper triangle
      qii_m_qjj = dQ[i] - dqj;
      if(fabs(qii_m_qjj) < 100.0*DBL_EPSILON ) {
        S_sym[i + n*j] = p_0[i] * delta;
      } else if(qii_m_qjj < 0) {
        S_sym[i + n*j] = p_0[j] * (expm1(qii_m_qjj*delta)/qii_m_qjj);
      } else { // ensure use of neg sign, avoids overflow in expm1
        S_sym[i + n*j] = p_0[i] * (expm1(-qii_m_qjj*delta)/(-qii_m_qjj));
      }
    }
  }
  free(dQ);
  
  /* populate S */
  for( j=0; j<n; j++){
    for( i=0; i<n; i++){
      if(i==j){ // diagonal
        S[i + n*i] = p_0[i];
      } else if(i<j){ // upper triangle
        S[i + n*j] = Q[i + n*j] * S_sym[i + n*j];
      } else{ // lower triangle
        S[i + n*j] = Q[i + n*j] * S_sym[j + n*i]; // transpose S_sym
      }
    }
  }
  free(p_0);
  free(S_sym);
  
  if(n_sq > 0){
    matsq(n, n_sq, S); // squaring loop
  }
}

/* Compute z := z^{(2^K)}, via looping: w<-z*z; z<-w; (w is temp storage) */
void matsq(int n, int k, double *z)
{
  int i;
  static const char *transa = "N";
  static const double one = 1.0, zero = 0.0;
  size_t nSqr = n * ((size_t) n);
  double* w = (double*)malloc(sizeof(double) * nSqr); // temp storage for dgemm
  
  for (i = 0; i < k; i++){
    /* w <- z*z  */
    F77_CALL(dgemm)(transa, transa, &n, &n, &n, &one,
             z, &n, z, &n, &zero, w, &n FCONE FCONE);
    Memcpy(z, w, nSqr); /* z <- w  */
  }
  
  free(w);
}